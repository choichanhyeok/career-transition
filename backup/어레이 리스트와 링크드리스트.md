> ## A. 무엇을 준비해야 하나
```
Array: 컴퓨터에서의 배열 메모리 관리, 메모리 참조 주소 관점에서 학습
ArrayList vs LinkedList: 개념, 연산의 시간 복잡도 (삽입, 삭제, 조회), 장단점 비교 및 사용 상황 파악
``` 

- `Context 1`. 컴퓨터에서 메모리 관점에서의 배열이라는 자료구조에 대해 학습
- `Context 2`. 자바에서의 ArrayList와 Linked의 작업 별 차이 (삽입, 삭제, 조회에 대한 각각의 장단점)
- `Context 3`. ArrayList를 사용하면 좋은 상황과 LinkedList를 사용하면 좋은 상황


<br>
<br>




> ## B. 어떤 부분을 고려해야 하나
```
너무 깊지 않게, 딱 필요한 부분만 학습.
결국 원하는 건 메모리 관점에서 어떤 차이가 있느냐랑
이로 인한 삽입, 삭제, 조회에 성능 차이에 대한 이해이다.
```

#### (1) 목적
- `TODO 1`. Array는 메모리 관점으로 어떻게 되어 있는가
  - 원래는 연속적인 메모리를 할당해 데이터를 관리하는 컨셉
  - 이런 연속성 때문에 최초 주소와 자료형, 인덱스만 알면 해당 인덱스의 위치를 바로 계산해서 찾을 수 있는 이점이 있다.
  - 다만, 이런 연속적인 공간을 보장해야해서 최초 배열 생성시에 배열의 크기를 고정해야하고 변경하려면 재할당 해야한다는 한계가 있다.
  - 이렇게 비교적 데이터 구조가 일차원 적이어서 한번에 연속된 주변 메모리 정보나 블록 단위, 시간 단위로 캐싱하는 처리등이 가능해 조회 성능을 높일 수 있다.
  - 자바에선 배열도 객체 취급을 하는데 컨셉은 비슷하나 한번 래핑한거라 잘못된 주소에 접근하면 `ArrayIndexOutOfBoundsException`을 내려줄 수 있습니다.
  - 자바의 ArrayList는 이 Array를 기반으로 하는데 Array와 다르게 값들이 모두 초기화가 안되었더라도 객체 생성시에 할당받은 크기 만큼 배열 값을 추가 가능 (단, 초과시 재할당: capacy 초기 empty로 시작하고 최초 값 삽입시 10으로 시작함)

- `TODO 2`. ArrayList와 LinkedList의 차이
  - 조회 성능: ArrayList는 인덱스를 아는 상황에선 조회 성능이 O(1)입니다. 반면 LinkedList는 O(N)입니다.
  - 삽입, 삭제 성능: ArrayList의 경우 어디에 삽입하든 O(N)의 시간 복잡도를 가집니다. 근데 사실 LinkedList도 최초 삽입 아니면 조회 때문에 O(N)의 시간 복잡도를 갖는 건 매한가진데 대신 추가되는 노드에 대한 객체 생성 비용만 소모된다는 이점이 있습니다. ArrayList는 배열 기반이어서 수정 하려면 배열을 재할당 해야하고 ArrayList 객체도 재생성 해야해서 여기서 비용이 많이 발생합니다.


- `TODO 3`. 어떨 때 뭘 쓰면 좋은가요?
  - a. 인덱스를 통한 읽기 작업이 많을 때: `ArrayList`
  - b. 배열 크기를 초과하는 인풋이 빈번히 일어나지 않는데 값을 끝에 순차적으로 추가할 때: `ArrayList`
  - c. 중간에 값 삽입, 삭제가 많고 이를 최적화 하고 싶을 때: `LinkedList`
  - d. queue같이 선입 선출 구조로 대기열을 관리할 때




<br>
<br>


> ## C. 구체적인 진행 계획
```
(1) 언제까지
(2) 대략 어떤 식으로 만들지
(3) 검토 받고자 하는 건 무엇인지
(4) 정말로 검토가 필요한 부분인지
```

#### (1) 언제까지
- `PLAN 1`. 실제 기한 (ex. 2024-12-08, 19:00)
  - a. 시간이 없어 빨리 끝내야함
  - b. 그렇게 큰 공수가 들 만한 난이도는 아니라고 판단

#### (2) 대략 어떤 식으로 만들지
- `TODO`. 혼자 생각해보며 정리하기

#### (3) 검토 받고자 하는 건 무엇인지
- `CONTEXT 1`. 정리 한 방향이 맞는지. 면접 시에 이렇게 답변하면 되는지


#### (4) 정말로 검토가 필요한 부분인지
예 검토 필요.
